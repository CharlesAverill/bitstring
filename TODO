$Id$
Major to-do items.

(1) DONE - In bitmatch operator, use patterns not expressions.

(2) DONE - Allow matching against strings.

(3) DONE - Change the syntax so { ... } surrounds match patterns.

(4) Provide UInt32 and UInt64 types.

(5) Allow for specific offsets and alignment.  Something like this:

    { start : 16;
      another : 16 : offset(256);   (* location would be 256 bits from start *)
    }

(6) and:

    { start : 16;
      another : 16 : align(32);     (* implicit 16 bit gap before this *)
    }

(7) Assertions:

    { start : 16 : assert (offset = 0); }

   (Q: Are these evaluated at compile time or at run time or selectable?)

(8) Named but unbound patterns to avoid "Warning Y: unused variable".

(9) DONE -
    Make the error locations fine-grained, particularly so they point to
    individual fields, not the whole match.

(10) Cross-module, persistent, named patterns, see:
  http://caml.inria.fr/pub/ml-archives/caml-list/2008/04/25992c9c9fa999fe1d35d961dd9917a2.en.html

(11) Runtime endiannness expressions.  The suggested syntax is:

    { field : len : endianness(expr) }

    where expr would evaluate to something like `BigEndian or
    `LittleEndian.

    There are several protocols around where endianness is only
    determined at runtime, examples are libpcap and TIFF.

(12) DONE - More constant field lengths.

(13) Implement native endian functions.

(14) A proper test suite.

(15) More examples:

    ELF binaries
    GIF images
